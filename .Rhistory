library(devtools)
install.packages("devtools")
install.packages("git2r")
install.packages("httr")
install.packages("usethis")
install.packages("openssl")
install.packages("devtools")
install.packages("devtools")
library(devtools)
library(up.down.ld50)
library(up.down.ld50)
library(up.down.ld50)
library(up.down.ld50)
library(up.down.ld50)
library(up.down.ld50)
library(up.down.ld50)
library(up.down.ld50)
library(up.down.ld50)
library(up.down.ld50)
library(up.down.ld50)
library(up.down.ld50)
up_down_ld50(end_point = 0.07,
steps = c( 0.008, 0.02, 0.04, 0.07, 0.16, 0.4, 0.6, 1, 2),
step_type = "weight", filament = "costum",
response_pattern = "xoxoxx", ID = 1,
delta_type = "flexible")
example("up_down_ld50")
library(up.down.ld50)
library(up.down.ld50)
example("up_down_ld50")
example("up_down_ld50")
up_down_ld50 = function(end_point, steps, log_steps = FALSE,
response_pattern, ID, verbose = FALSE,
delta_type = c("flexible", "constant", "exact")){
# only use first value in each step
delta_type = delta_type[1]
response_pattern = toupper(response_pattern)
# check if end_point is one of the steps
if ( ! end_point %in% steps  ){
return("end_point not in steps")
} else {
i = match(end_point, steps)
}
# change steps to to log scale
if ( ! log_steps){
steps = log10(steps)
}
# calculate estimated LD50
if ( all.character.same(response_pattern) ){
char = strsplit(response_pattern, "")[[1]][1]
if (char == "X"){
mu = paste0( "<" , as.character( end_point ) )
} else{
mu = paste0( ">" , as.character( end_point ) )
}
} else if( delta_type[1] == "exact"){
if ( ! log_steps ){
end_point = log10(end_point)
}
# calculate expected mean based on actual steps and negative log likelihood
index = index_from_res( end_index = i, res = response_pattern)
d = flexible_d( end_index = i, res = response_pattern, steps = steps )
# optimize for mu
mu_opt = ( optimize(nll.cnorm,
end_point + d * c(-2,2),
x = steps[index],
response =  response_pattern ,
sd = d)$minimum )
if (log_steps){
mu = as.character(10^(mu_opt)/10000)
} else{
mu = as.character(10^(mu_opt))
}
} else {
# get k from negative log likelihood function, based on the response_pattern:
k = ( optimize(nll.setD,
end_from_response(response_pattern) + c(-10,10),
x0 = end_from_response(response_pattern),
response = response_pattern )$minimum -
end_from_response(response_pattern) )
# get delta value based on delta type
if (delta_type[1] == "flexible"){
d = flexible_d(end_index = i, res = response_pattern, steps = steps)
} else if (delta_type == "constant") {
d = mean( steps[2 : length(steps)] - steps[1 : (length(steps) - 1)])
}
if (log_steps){
mu = as.character( 10^( end_point + d*k )/10000 )
} else {
mu = as.character( 10^( log10( end_point ) + d*k ) )
} else {
return("Non valid delta_type")
}
}
if (verbose){
text = sprintf("Sensitivity to evoked mechanical stimulation was assessed using a series of calibrated von Frey monoﬁlaments (%s). The Dixon up and down method was used to calculate the 50% withdrawal threshold [1]. The calculation was made with up_down_ld50 {up.down.ld50} [2] using the handle number/force and a constant delta-value of XXX/flexible delta-value [3].
1. Reference to Dixon 1980 paper
2. Reference to program
3. Reference to our manuscript", paste(steps) )
return (text)
}else{
return (mu)
}
}
verbose = T
up_down_ld50 = function(end_point, steps, log_steps = FALSE,
response_pattern, ID, verbose = FALSE,
delta_type = c("flexible", "constant", "exact")){
# only use first value in each step
delta_type = delta_type[1]
response_pattern = toupper(response_pattern)
# check if end_point is one of the steps
if ( ! end_point %in% steps  ){
return("end_point not in steps")
} else {
i = match(end_point, steps)
}
# change steps to to log scale
if ( ! log_steps){
steps = log10(steps)
}
# calculate estimated LD50
if ( all.character.same(response_pattern) ){
char = strsplit(response_pattern, "")[[1]][1]
if (char == "X"){
mu = paste0( "<" , as.character( end_point ) )
} else{
mu = paste0( ">" , as.character( end_point ) )
}
} else if( delta_type[1] == "exact"){
if ( ! log_steps ){
end_point = log10(end_point)
}
# calculate expected mean based on actual steps and negative log likelihood
index = index_from_res( end_index = i, res = response_pattern)
d = flexible_d( end_index = i, res = response_pattern, steps = steps )
# optimize for mu
mu_opt = ( optimize(nll.cnorm,
end_point + d * c(-2,2),
x = steps[index],
response =  response_pattern ,
sd = d)$minimum )
if (log_steps){
mu = as.character(10^(mu_opt)/10000)
} else{
mu = as.character(10^(mu_opt))
}
} else {
# get k from negative log likelihood function, based on the response_pattern:
k = ( optimize(nll.setD,
end_from_response(response_pattern) + c(-10,10),
x0 = end_from_response(response_pattern),
response = response_pattern )$minimum -
end_from_response(response_pattern) )
# get delta value based on delta type
if (delta_type[1] == "flexible"){
d = flexible_d(end_index = i, res = response_pattern, steps = steps)
} else if (delta_type == "constant") {
d = mean( steps[2 : length(steps)] - steps[1 : (length(steps) - 1)])
}
if (log_steps){
mu = as.character( 10^( end_point + d*k )/10000 )
} else {
mu = as.character( 10^( log10( end_point ) + d*k ) )
} else {
return("Non valid delta_type")
}
}
if (verbose){
text = sprintf("Sensitivity to evoked mechanical stimulation was assessed using a series of calibrated von Frey monoﬁlaments (%s). The Dixon up and down method was used to calculate the 50% withdrawal threshold [1]. The calculation was made with up_down_ld50 {up.down.ld50} [2] using the handle number/force and a constant delta-value of XXX/flexible delta-value [3].
1. Reference to Dixon 1980 paper
2. Reference to program
3. Reference to our manuscript", paste(steps) )
return (text)
} else {
return (mu)
}
}
up_down_ld50 = function(end_point, steps, log_steps = FALSE,
response_pattern, ID, verbose = FALSE,
delta_type = c("flexible", "constant", "exact")){
# only use first value in each step
delta_type = delta_type[1]
response_pattern = toupper(response_pattern)
# check if end_point is one of the steps
if ( ! end_point %in% steps  ){
return("end_point not in steps")
} else {
i = match(end_point, steps)
}
# change steps to to log scale
if ( ! log_steps){
steps = log10(steps)
}
# calculate estimated LD50
if ( all.character.same(response_pattern) ){
char = strsplit(response_pattern, "")[[1]][1]
if (char == "X"){
mu = paste0( "<" , as.character( end_point ) )
} else{
mu = paste0( ">" , as.character( end_point ) )
}
} else if( delta_type[1] == "exact"){
if ( ! log_steps ){
end_point = log10(end_point)
}
# calculate expected mean based on actual steps and negative log likelihood
index = index_from_res( end_index = i, res = response_pattern)
d = flexible_d( end_index = i, res = response_pattern, steps = steps )
# optimize for mu
mu_opt = ( optimize(nll.cnorm,
end_point + d * c(-2,2),
x = steps[index],
response =  response_pattern ,
sd = d)$minimum )
if (log_steps){
mu = as.character(10^(mu_opt)/10000)
} else{
mu = as.character(10^(mu_opt))
}
} else {
# get k from negative log likelihood function, based on the response_pattern:
k = ( optimize(nll.setD,
end_from_response(response_pattern) + c(-10,10),
x0 = end_from_response(response_pattern),
response = response_pattern )$minimum -
end_from_response(response_pattern) )
# get delta value based on delta type
if (delta_type[1] == "flexible"){
d = flexible_d(end_index = i, res = response_pattern, steps = steps)
} else if (delta_type == "constant") {
d = mean( steps[2 : length(steps)] - steps[1 : (length(steps) - 1)])
}
if (log_steps){
mu = as.character( 10^( end_point + d*k )/10000 )
} else {
mu = as.character( 10^( log10( end_point ) + d*k ) )
} else {
return("Non valid delta_type")
}
}
if (verbose){
text = sprintf("Sensitivity to evoked mechanical stimulation was assessed using a series of calibrated von Frey monoﬁlaments (%s). The Dixon up and down method was used to calculate the 50% withdrawal threshold [1]. The calculation was made with up_down_ld50 {up.down.ld50} [2] using the handle number/force and a constant delta-value of XXX/flexible delta-value [3].
1. Reference to Dixon 1980 paper
2. Reference to program
3. Reference to our manuscript", paste(steps) )
return (text)
} else {
return (mu)
}
}
if (verbose){
text = sprintf("Sensitivity to evoked mechanical stimulation was assessed using a series of calibrated von Frey monoﬁlaments (%s). The Dixon up and down method was used to calculate the 50% withdrawal threshold [1]. The calculation was made with up_down_ld50 {up.down.ld50} [2] using the handle number/force and a constant delta-value of XXX/flexible delta-value [3].
1. Reference to Dixon 1980 paper
2. Reference to program
3. Reference to our manuscript", paste(steps) )
return (text)
} else {
return (mu)
}
verbose = F
up_down_ld50 = function(end_point, steps, log_steps = FALSE,
response_pattern, ID, verbose = FALSE,
delta_type = c("flexible", "constant", "exact")){
# only use first value in each step
delta_type = delta_type[1]
response_pattern = toupper(response_pattern)
# check if end_point is one of the steps
if ( ! end_point %in% steps  ){
return("end_point not in steps")
} else {
i = match(end_point, steps)
}
# change steps to to log scale
if ( ! log_steps){
steps = log10(steps)
}
# calculate estimated LD50
if ( all.character.same(response_pattern) ){
char = strsplit(response_pattern, "")[[1]][1]
if (char == "X"){
mu = paste0( "<" , as.character( end_point ) )
} else{
mu = paste0( ">" , as.character( end_point ) )
}
} else if( delta_type[1] == "exact"){
if ( ! log_steps ){
end_point = log10(end_point)
}
# calculate expected mean based on actual steps and negative log likelihood
index = index_from_res( end_index = i, res = response_pattern)
d = flexible_d( end_index = i, res = response_pattern, steps = steps )
# optimize for mu
mu_opt = ( optimize(nll.cnorm,
end_point + d * c(-2,2),
x = steps[index],
response =  response_pattern ,
sd = d)$minimum )
if (log_steps){
mu = as.character(10^(mu_opt)/10000)
} else{
mu = as.character(10^(mu_opt))
}
} else {
# get k from negative log likelihood function, based on the response_pattern:
k = ( optimize(nll.setD,
end_from_response(response_pattern) + c(-10,10),
x0 = end_from_response(response_pattern),
response = response_pattern )$minimum -
end_from_response(response_pattern) )
# get delta value based on delta type
if (delta_type[1] == "flexible"){
d = flexible_d(end_index = i, res = response_pattern, steps = steps)
} else if (delta_type == "constant") {
d = mean( steps[2 : length(steps)] - steps[1 : (length(steps) - 1)])
}
if (log_steps){
mu = as.character( 10^( end_point + d*k )/10000 )
} else {
mu = as.character( 10^( log10( end_point ) + d*k ) )
} else {
return("Non valid delta_type")
}
}
if (verbose){
text = sprintf("Sensitivity to evoked mechanical stimulation was assessed using a series of calibrated von Frey monoﬁlaments (%s). The Dixon up and down method was used to calculate the 50% withdrawal threshold [1]. The calculation was made with up_down_ld50 {up.down.ld50} [2] using the handle number/force and a constant delta-value of XXX/flexible delta-value [3].
1. Reference to Dixon 1980 paper
2. Reference to program
3. Reference to our manuscript", paste(steps) )
return (text)
} else {
return (mu)
}
}
up_down_ld50 = function(end_point, steps, log_steps = FALSE,
response_pattern, ID, verbose = FALSE,
delta_type = c("flexible", "constant", "exact")){
# only use first value in each step
delta_type = delta_type[1]
response_pattern = toupper(response_pattern)
# check if end_point is one of the steps
if ( ! end_point %in% steps  ){
return("end_point not in steps")
} else {
i = match(end_point, steps)
}
# change steps to to log scale
if ( ! log_steps){
steps = log10(steps)
}
# calculate estimated LD50
if ( all.character.same(response_pattern) ){
char = strsplit(response_pattern, "")[[1]][1]
if (char == "X"){
mu = paste0( "<" , as.character( end_point ) )
} else{
mu = paste0( ">" , as.character( end_point ) )
}
} else if( delta_type[1] == "exact"){
if ( ! log_steps ){
end_point = log10(end_point)
}
# calculate expected mean based on actual steps and negative log likelihood
index = index_from_res( end_index = i, res = response_pattern)
d = flexible_d( end_index = i, res = response_pattern, steps = steps )
# optimize for mu
mu_opt = ( optimize(nll.cnorm,
end_point + d * c(-2,2),
x = steps[index],
response =  response_pattern ,
sd = d)$minimum )
if (log_steps){
mu = as.character(10^(mu_opt)/10000)
} else{
mu = as.character(10^(mu_opt))
}
} else {
# get k from negative log likelihood function, based on the response_pattern:
k = ( optimize(nll.setD,
end_from_response(response_pattern) + c(-10,10),
x0 = end_from_response(response_pattern),
response = response_pattern )$minimum -
end_from_response(response_pattern) )
# get delta value based on delta type
if (delta_type[1] == "flexible"){
d = flexible_d(end_index = i, res = response_pattern, steps = steps)
} else if (delta_type == "constant") {
d = mean( steps[2 : length(steps)] - steps[1 : (length(steps) - 1)])
}
if (log_steps){
mu = as.character( 10^( end_point + d*k )/10000 )
} else {
mu = as.character( 10^( log10( end_point ) + d*k ) )
}
}
if (verbose){
text = sprintf("Sensitivity to evoked mechanical stimulation was assessed using a series of calibrated von Frey monoﬁlaments (%s). The Dixon up and down method was used to calculate the 50% withdrawal threshold [1]. The calculation was made with up_down_ld50 {up.down.ld50} [2] using the handle number/force and a constant delta-value of XXX/flexible delta-value [3].
1. Reference to Dixon 1980 paper
2. Reference to program
3. Reference to our manuscript", paste(steps) )
return (text)
} else {
return (mu)
}
}
library(up.down.ld50)
example("up_down_ld50")
library(up.down.ld50)
library(up.down.ld50)
example("up_down_ld50")
all.character.same = function(string){
s = strsplit(string, "")
s = s[[1]]
for (i in 1:(length(s)-1 ) ){
if (s[i] != s[i+1]){
return (FALSE)
}
}
return (TRUE)
}
example("up_down_ld50")
library(up.down.ld50)
example("up_down_ld50")
library(up.down.ld50)
example("up_down_ld50")
library(up.down.ld50)
example("up_down_ld50")
library(up.down.ld50)
example("up_down_ld50")
?S3method
?S3
library(up.down.ld50)
example("up_down_ld50")
library(up.down.ld50)
example("up_down_ld50")
library(up.down.ld50)
example("up_down_ld50")
library(up.down.ld50)
example("up_down_ld50")
library(up.down.ld50)
example("up_down_ld50")
up_down_ld50(end_point = 0.07,steps = c( 0.008, 0.02, 0.04, 0.07, 0.16, 0.4, 0.6, 1, 2),
log_steps = F,
response_pattern = "xoxoxx", ID = 1,
delta_type = "flexible", verbose = T)
library(up.down.ld50)
up_down_ld50(end_point = 0.07,steps = c( 0.008, 0.02, 0.04, 0.07, 0.16, 0.4, 0.6, 1, 2),
log_steps = F,
response_pattern = "xoxoxx", ID = 1,
delta_type = "flexible", verbose = T)
library(up.down.ld50)
up_down_ld50(end_point = 0.07,steps = c( 0.008, 0.02, 0.04, 0.07, 0.16, 0.4, 0.6, 1, 2),
log_steps = F,
response_pattern = "xoxoxx", ID = 1,
delta_type = "flexible", verbose = T)
steps
library(up.down.ld50)
up_down_ld50(end_point = 0.07,steps = c( 0.008, 0.02, 0.04, 0.07, 0.16, 0.4, 0.6, 1, 2),
log_steps = F,
response_pattern = "xoxoxx", ID = 1,
delta_type = "flexible", verbose = T)
paste(0,24,1,1,3,5)
library(up.down.ld50)
paste(0,24,1,1,3,5)
up_down_ld50(end_point = 0.07,steps = c( 0.008, 0.02, 0.04, 0.07, 0.16, 0.4, 0.6, 1, 2),
log_steps = F,
response_pattern = "xoxoxx", ID = 1,
delta_type = "flexible", verbose = T)
library(up.down.ld50)
up_down_ld50(end_point = 0.07,steps = c( 0.008, 0.02, 0.04, 0.07, 0.16, 0.4, 0.6, 1, 2),
log_steps = F,
response_pattern = "xoxoxx", ID = 1,
delta_type = "flexible", verbose = T)
library(up.down.ld50)
up_down_ld50(end_point = 0.07,steps = c( 0.008, 0.02, 0.04, 0.07, 0.16, 0.4, 0.6, 1, 2),
log_steps = F,
response_pattern = "xoxoxx", ID = 1,
delta_type = "flexible", verbose = T)
library(up.down.ld50)
up_down_ld50(end_point = 0.07,steps = c( 0.008, 0.02, 0.04, 0.07, 0.16, 0.4, 0.6, 1, 2),
log_steps = F,
response_pattern = "xoxoxx", ID = 1,
delta_type = "flexible", verbose = T)
library(up.down.ld50)
up_down_ld50(end_point = 0.07,steps = c( 0.008, 0.02, 0.04, 0.07, 0.16, 0.4, 0.6, 1, 2),
log_steps = F,
response_pattern = "xoxoxx", ID = 1,
delta_type = "flexible", verbose = T)
library(up.down.ld50)
up_down_ld50(end_point = 0.07,steps = c( 0.008, 0.02, 0.04, 0.07, 0.16, 0.4, 0.6, 1, 2),
log_steps = F,
response_pattern = "xoxoxx", ID = 1,
delta_type = "flexible", verbose = T)
require("devtools")
if(require("devtools")){print("hello")}
if(require("sfes")){print("hello")}
if(!( "devtools" %in% installed.packages()[,"Package"] ) ){install.packages("devtools")}
library(devtools)
install_github("MikkelAS/up.down.ld50")
install_bitbucket("MikkelAS/up.down.ld50")
library(up.down.ld50)
library(up.down.ld50)
example("up_down_ld50")
