#!/usr/bin/env Rscript
#### libraries ####
library(data.table)
library(stringr)
#library(readr)
library(ggplot2)
library(tibble)
#### Insert user data ####
# Set working directory, where the output is to be printed.
# setwd("/home/mikkel/Documents/sym_test_data/")
# setwd("/home/mikkel/Documents/sym_test_data/TargetI_without_symplex")
# setwd("/home/mikkel/Documents/sym_test_data/TargetI_with_symplex")
# setwd("/home/mikkel/Documents/sym_test_data/TargetH")
# setwd("/home/mikkel/Documents/sym_test_data/TNFR2/")
# symplex AA to cut off
symplex_end = 7

File_names = c(
    "TNFR2 matrix seq analysis 18-12-2018 with selection CURRENT.csv"
)


seperators = c( ";", ";", ";")
# main file with matrix analysis
dat = read.csv(file = File_names[1] , sep = seperators[1], stringsAsFactors = F)
full_sequences_given = T

# name of the column with clusters in. Example "partis.clusters"
cluster_column = "Parties..cluster.VH"
# Name of column with 0,1 info on if it is a binders "HIT.1:5..Hu". This is used to remove alle none binders. 
# If you wish to compare binders with total library then enter the column as a selection column
Binder_column = ""
# Name of column with names in. Example c( "Name", "DNA", "GP.Name")
Binder_names = c( "Name")

# Name of selection columns. Example c( "Selected.for.Sanger.seq..671", "Final.for.smallscale.prod..367.Aug2018")
multiselection = F
if (multiselection){
  multi_name = c("Immunization.arm..Barcode.")
}
Selected_for_names = c("Binders.COMBO", "CURRENT.SELECTION")
# true values
true_values = c("(x)", 1, "sanger")
# Names for binders and selection steps on final output. Has to be equal to or one more than 
# Selected_for_names (the first input name repressents the whole library after removal of Binder_column)
# Example c("Binders", "Sanger", "Final")
Final_names = c("All", "Binders", "Selected")

#### Define functions ####

paste3 <- function(...,sep=", ") {
  L <- list(...)
  L <- lapply(L,function(x) {x[is.na(x)] <- ""; x})
  ret <-gsub(paste0("(^",sep,"|",sep,"$)"),"",
             gsub(paste0(sep,sep),sep,
                  do.call(paste,c(L,list(sep=sep)))))
  is.na(ret) <- ret==""
  ret
}

is.even = function( numbers ){
  # determines if a number is equal
  result = rep( F, length(numbers) )
  i = 1
  for (n in numbers){
    if( is.na(n) ){
      NULL
    } else if ( round(n/2) == n/2 && as.integer(n) == n){
      result[i] = T
    }
    i = i + 1
  }
  return(result)
}

duplicated_with_logic_position = function(data_v, logic_list, fromLast = FALSE){
  # find positions that are dublicated while removing positions that are false in the logic_list
  data_v[!logic_list] = NA
  dup_logic = duplicated(data_v, fromLast = fromLast)
  
  # make the inserted NA a False dublicate.
  if (any(!logic_list)){
    if( fromLast ){
      dup_logic[ max( which(!logic_list)) ] = F
    } else{
      dup_logic[ min( which(!logic_list)) ] = F
    }
  }
  
  return(dup_logic)
}


# turn each position to a numeric value and compare. Return logic vector.
below = function(data_v, comparison){
  logic_vector = rep(F, length(data_v))
  for( i in 1:length(logic_vector)){
    if( !is.na(data_v[i]) ){
      if (data_v[i] < comparison){
        logic_vector[i] = T
      }
    } 
  }
  
  
  return(logic_vector)
}

create_summary_line_logic = function(name, data_v, col_v, logic_list, logic, comparison, logic_output = FALSE ){
  ### create a line for the summary vector with clone and cluster count for each column in logic_list. 
  
  # save full data
  full_data = data_v
  
  # start the new line with a name.
  new_row = as.character( name )
  
  # split logic and take the first points_to_use as AND on top of a full TRUE vector
  logic = strsplit( as.character( logic ), split = " ")[[1]]
  logic = c( "AND", logic ) 
  
  # split the comparison up if it contains spaces.
  input_comparison = strsplit( as.character( comparison), split = " ")[[1]]
  
  # make single input comparisons fit the length of the logic.
  if( length(input_comparison) == 1 ){
    input_comparison = rep(input_comparison, length(logic)/2 )
  }
  
  # if there are more logics to compare make more logic lists
  if( is.vector( logic_list )){
    number_of_logic_lists = 1
  } else{
    number_of_logic_lists = ncol(logic_list)
  }
  
  # do the logic comparison
  for ( i in 1:number_of_logic_lists){
    
    if( is.vector( logic_list )){
      points_to_use_final = logic_list
      this_round_logic = logic_list
    } else{
      points_to_use_final = logic_list[,i]
      this_round_logic = logic_list[,i]
    }
    
    # Use data_v as matrix or list
    if( is.matrix(full_data)){
      data_v = full_data[,i]
    }
    
    # empty strings are NA
    data_v[ data_v == "" ] = NA
    
    # use even numbered logici symbols to compare input data
    for( j in (1:(length(logic)/2) )* 2 ){
      # define the logic for this run trough
      l = logic[j]
      # define comparison for this run trough.
      comparison = type.convert(input_comparison[j/2])
      if ( is.na( comparison ) ){
        comparison = ""
      }
      
      # first create the logic list to be used
      if(l == "!="){
        points_to_use = (!data_v %in% comparison) & this_round_logic 
        
      } else if(l == "=="){
        points_to_use = (data_v %in% comparison) & this_round_logic
        
      } else if(l == "<"){
        points_to_use = below( data_v, comparison) & this_round_logic
        
      } else if(l == "uniq"){
        points_to_use = !duplicated_with_logic_position( data_v, this_round_logic )  
        
      } else if(l == "only"){
        points_to_use = !duplicated_with_logic_position( data_v, this_round_logic ) & 
          !duplicated_with_logic_position( data_v, this_round_logic, fromLast = T )
        
      } else if(l == "duplicate"){
        points_to_use = duplicated_with_logic_position( data_v, this_round_logic ) | 
          duplicated_with_logic_position( data_v, this_round_logic, fromLast = T )
        
      } else if(l == "is.na"){
        points_to_use = is.na( data_v ) & this_round_logic
        
      } else if(l == "even"){
        points_to_use = is.even( data_v ) & this_round_logic
        
      } else if(l == "uneven"){
        points_to_use = (!is.even( data_v )) & this_round_logic
        
      } else if(l == "regex"){
        points_to_use = str_detect( data_v , regex(comparison) ) & this_round_logic
        
      } else if(l == "regex_cdr2"){
        points_to_use = str_detect( dat$VH.CDR2 , regex(comparison) ) & this_round_logic
        
      }
      
      
      # use uneven numbered logical input to combine multiple comparisons. This will only take the comparison in kronological order.
      if (logic[j-1] == "AND"){
        points_to_use_final = points_to_use_final & points_to_use
      } else if (logic[j-1] == "OR"){
        points_to_use_final = points_to_use_final | points_to_use
      } else if (logic[j-1] == "NOR"){
        points_to_use_final = !(points_to_use_final | points_to_use) & this_round_logic
      }
      
      
      if(l != "is.na"){
        # Remove NA values from true
        points_to_use_final = !( !points_to_use_final | is.na(data_v) )
      }
    }
    
    
    
    if(logic_output){
      return(points_to_use_final)
    }
    
    # Add clone and cluster count to the new row 
    new_row = c( new_row, sum( points_to_use_final ), length( unique( col_v[points_to_use_final] ) ) )
  }
  
  return( new_row )
}


#### Start up, load colors. ####
list.of.packages <- c("ggplot2", "readr", "tibble")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

# set up symphogen colors.
#source( file = "../Rscripts/sym_col.R")
## Symphogen colors for R if you do not have the sym_col.R file
if(T){
  sym_col = c( rgb( 0, 172, 235, max = 255 ),
               rgb( 52, 71, 80, max = 255),
               rgb( 188, 27, 140, max = 255),
               rgb( 109, 157, 48, max = 255 ),
               rgb( 242, 100, 34, max = 255),
               rgb( 107, 142, 159, max = 255 ),
               rgb( 161, 161, 161, max = 255),
               rgb( 192, 192, 192, max = 255 ) )
}

#### modify original data set if need be ####
# remove non binders
if(Binder_column != ""){
  # Find all binders.
  binders = unname( unlist( dat[,Binder_column])) == 1
  for (i in 1:length(binders)){
    if (is.na(binders[i])){
      binders[i] = FALSE
    }
  }
  
  # Only keep binders.
  dat = dat[binders,]
}

# merge with columns from data sets
if( length(File_names) > 1 ){
  # run trough the different file names.
  for (j in 2:length(File_names)){
    # read file 
    dat_2 = read.csv(file = File_names[j], sep = seperators[j], stringsAsFactors = F)
    # Find all binders.
    binders = unname( unlist( dat_2[,Binder_names[j]]))
    temp_names = rep("", length(binders))
    for (i in 1:length(binders)){
      temp_names[i] = strsplit( as.character( binders[i] ), "_VH" )[[1]]
    }
    dat_2[,Binder_names[j]] = temp_names
    # Add additional information.
    dat = merge( x = dat, y = dat_2, by.x = Binder_names[1], by.y = Binder_names[j], all.x = T, suffixes = c("",".y"))
    dat_2 = 0
  }

}

for (n in names(dat)){
  rep_col = n
  rep_col_y = paste0(rep_col, ".y")
  if ( rep_col_y %in% names(dat) ){
    #print(n)
    not_na_positions = !(is.na( dat[,rep_col_y] ) | dat[,rep_col_y] == "")
    dat[,rep_col][ not_na_positions ] =  dat[,rep_col_y][ not_na_positions ]
    dat[,rep_col_y] = NULL
  }
}




#### create selection vectors ####

# make T/F for selected indexes.
Selected_for = matrix( rep(T, nrow(dat)), ncol = 1 )
for (name in Selected_for_names){
  Selected_for = cbind( Selected_for, dat[,name] %in% true_values )
  
}

# remove all true column if it is not in the Final_names
if ( length(Selected_for_names) == length( Final_names ) ){
  Selected_for = Selected_for[,2:ncol(Selected_for)]
} 

# add multiselection columns
if (multiselection){
  # get all selections in columns
  new_selected_for_names = sort( unique( dat[,multi_name] ) )
  # make boolen column and add names
  for (name in new_selected_for_names){
    Selected_for_names = c(Selected_for_names, name)
    Final_names = c( Final_names, name)
    Selected_for = cbind( Selected_for, dat[,multi_name] %in% name )
  }
}

# fill in with false for NA
Selected_for[ is.na(Selected_for) ] = FALSE

#### Full sequences ####
if (full_sequences_given){
  
  dat$full_VH = dat$VH
  dat$full_VL = dat$VL
  dat$full = paste3(dat$full_VH, dat$full_VL, sep = "")
  dat$full_CDR = paste( dat$VL.CDR1, dat$VL.CDR2, dat$VL.CDR3, 
                        dat$VH.CDR1, dat$VH.CDR2, dat$VH.CDR3, sep = "")
 
} else {
  # clean up the sequence data (insert NA at 0 strings)
  indexes = paste0( rep( c( "VH.", "VL."), c(7,7) ), 
                    rep( rep( c("FR", "CDR"), c(4,3)), 2), 
                    as.character( rep( c(1:4,1:3),2) ) ) 
  for (ind in indexes){
    dat[,ind][ dat[,ind] == 0 ] <- NA
  }
  
  # get full VH and VL
  dat$full_VH = paste3( substring( dat$VH.FR1, symplex_end), dat$VH.CDR1, 
                        dat$VH.FR2, dat$VH.CDR2, 
                        dat$VH.FR3, dat$VH.CDR3, dat$VH.FR4, sep = "")
  
  dat$full_VL = paste3( substring( dat$VL.FR1, symplex_end), dat$VL.CDR1, 
                        dat$VL.FR2, dat$VL.CDR2, 
                        dat$VL.FR3, dat$VL.CDR3, dat$VL.FR4, sep = "")
  # cat VH+VL ot full total
  dat$full = paste3(dat$full_VH, dat$full_VL, sep = "")
  
  # get full CDR
  dat$full_CDR = paste( dat$VL.CDR1, dat$VL.CDR2, dat$VL.CDR3, 
                        dat$VH.CDR1, dat$VH.CDR2, dat$VH.CDR3, sep = "")
  
}


#### Create parameter overview file ####

# Define summary matrix with header written in.
summa = matrix("Parameter", nrow = 1)

# add column headers for each selection
for ( name in Final_names){
  summa = cbind( summa, name, paste(name, "(clusters)") )
}
colnames(summa) = NULL


## define data.frame with the logical input we want in the output. 
# here the data column that repressents the input in inserted
data_v = c(as.list( list( dat[,Binder_names[1]] )), 
           as.list( list( dat$full ) ), 
           as.list( list( dat$full_CDR) ),
           as.list( list( dat[, cluster_column]) ),
           as.list( list( dat$full_VH) ),
           as.list( list( dat$full_VL) ), 
           as.list( list( dat$full ) ),
           as.list( list( dat$VH.Cys) ),
           as.list( list( dat$VL.Cys) ),
           as.list( list( dat$VL.Cys + dat$VH.Cys) ),
           as.list( list( dat$VL.Cys + dat$VH.Cys) ),
           as.list( list( dat$VH.Deamidation) ),
           as.list( list( dat$VH.DP) ),
           as.list( list( dat$VH.Nglyc) ),
           as.list( list( dat$VH.Nglyc) ),
           as.list( list( dat$VH.Nglyc) ),
           as.list( list( dat$VL.Deamidation) ),
           as.list( list( dat$VL.DP) ),
           as.list( list( dat$VL.Nglyc) ))

# here is the rest of the info eg. name, logic for comparison and comparison value that it should mantch/not match 
# (uniq and only does not use the comparison value, so just enter an empyt string)

input_for_summa = t( matrix( c( "Total","!=","",
                                "Unique Clones","uniq","",
                                "Unique CDR","uniq","", 
                                "Uniclone","only","", 
                                "Unique VH","uniq","",
                                "Unique VL" ,"uniq","",
                                "No protein sequence","is.na","",
                                "VH not 11 Cys","!=","11", 
                                "VL not 5 Cys","!=","5",
                                "Uneven total # of Cys","uneven","",
                                "Even total # Cys not 16","even AND !=","16",
                                "VH not 2 Deamination","!=","2", 
                                "VH not 1 DP site","!=","1", 
                                "VH not 1 Nglyc","!=","1",
                                "IGHV4-34 native Nglyc intact","== AND regex_cdr2","2 ^.N.([S,T])",
                                "VH problematic Nglyc","== AND regex_cdr2 NOR ==","2 ^.N.([S,T]) 1",
                                "VL not 2 Deamination","!=","0",
                                "VL not 1 DP site","!=","0",
                                "VL not 0 Nglyc","!=","0"
) , nrow = 3 ) )

colnames( input_for_summa ) = c("name", "logic", "comparison")
input_for_summa = data.frame(input_for_summa)



# add total count
for( i in 1:nrow(input_for_summa) ){
  summa = rbind(summa, create_summary_line_logic(name = input_for_summa$name[i], 
                                                 data_v = data_v[[i]], 
                                                 col_v = dat[, cluster_column], 
                                                 logic_list = Selected_for, 
                                                 logic = input_for_summa$logic[i], 
                                                 comparison = input_for_summa$comparison[i] ))
}
summa


write.table(summa, file = "Parameter_counts.csv", col.names = F, 
            row.names = F, sep = ",")

#### Create matrix with data on binders and selected sequences. ####

# print names of the sequences names in summa (the Parameter_counts.csv)
for (k in 1:ncol(Selected_for) ){
  # initiate print matrix for sequence data. 
  seq_data = matrix( ncol = 0, nrow = length(Selected_for[,k] ) )
  
  
  # add first line with sequence names
  i = 1
  # initiate new column
  append_col = rep("", nrow(seq_data))
  # find logic for which to include in it.
  append_logic = create_summary_line_logic(name = input_for_summa$name[i], 
                                           data_v = data_v[[i]], 
                                           col_v = dat[, cluster_column], 
                                           logic_list = Selected_for[,k], 
                                           logic = input_for_summa$logic[i], 
                                           comparison = input_for_summa$comparison[i],
                                           logic_output = T)
  
  # add x to the relevant columns to indicate which have the trait.
  append_col[append_logic] = unlist( lapply( dat[,Binder_names[1]][ append_logic ], as.character ) )
  # bind column to final output
  seq_data = cbind( seq_data, append_col)
  # add a column name
  colnames(seq_data)[ length(colnames(seq_data)) ] = as.character( input_for_summa$name[i] )
  
  
  
  # add trace back to dublicates.
  search_frase = "Unique"
  
  index = (1:nrow(input_for_summa))[ input_for_summa$name %like% "Unique" ]
  for (j in index){
    # find positions with duplicates
    data_vec = data_v[[j]]
    data_vec [ data_vec == "" ] = NA
    dupl_posit = create_summary_line_logic(name = input_for_summa$name[j], 
                                           data_v = data_vec, 
                                           col_v = dat[, cluster_column], 
                                           logic_list = Selected_for[,k], 
                                           logic = "duplicate", 
                                           comparison = input_for_summa$comparison[j],
                                           logic_output = T)
    uni_posit = create_summary_line_logic(name = input_for_summa$name[j], 
                                          data_v =  data_vec, 
                                          col_v = dat[, cluster_column], 
                                          logic_list = Selected_for[,k], 
                                          logic = input_for_summa$logic[j], 
                                          comparison = input_for_summa$comparison[j],
                                          logic_output = T)
    
    # start append col
    append_col = rep("", nrow(seq_data))
    
    # add names of duplicates to the right positions.
    for (l in (1:nrow(seq_data))[dupl_posit]){ # no longer with 
      append_col[l] = paste( dat[,Binder_names[1]] [  data_vec %in% data_vec[l] & !( 1:nrow(dat) %in% l ) ], collapse = ":")
    }
    
    # bind column to final output
    seq_data = cbind( seq_data, append_col)
    # add a column name
    colnames(seq_data)[ length(colnames(seq_data)) ] = paste( "Duplicate",
                                                              strsplit( as.character( input_for_summa$name[j] ), " ")[[1]][2] )
  }
  
  
  # add cystine problem columns
  
  # missing cys column 
  append_col = rep("", nrow(seq_data))
  # find logic for which to include in it.
  FR1_logic = !(create_summary_line_logic(name = "Missing Cys Position", 
                                          data_v = dat$VH.FR1, 
                                          col_v = dat[, cluster_column], 
                                          logic_list = Selected_for[,k], 
                                          logic = "regex", 
                                          comparison = "^.....................C",
                                          logic_output = T)[Selected_for[,k]] | is.na(dat$VH.FR1)[Selected_for[,k]] )
  CDR3_logic = !(create_summary_line_logic(name = "Missing Cys Positions", 
                                           data_v = dat$VH.CDR3, 
                                           col_v = dat[, cluster_column], 
                                           logic_list = Selected_for[,k], 
                                           logic = "regex", 
                                           comparison = "^C",
                                           logic_output = T)[Selected_for[,k]] | is.na(dat$VH.FR1)[Selected_for[,k]] )
  
  append_col[FR1_logic] = paste( append_col[FR1_logic], "FR1+21") 
  append_col[CDR3_logic] = paste( append_col[CDR3_logic], "CDR3+1")
  
  # bind column to final output
  seq_data = cbind( seq_data, append_col)
  # add a column name
  colnames(seq_data)[ length(colnames(seq_data)) ] = "Missing Cys Positions"
  
  
  # extra cys columns
  # add number of cys in each col
  col_names = c( "VH.CDR1", "VH.CDR2","VH.CDR3","VH.FR1","VH.FR2","VH.FR3","VH.FR4")
  for (col_nam in col_names){
    counts = str_count( dat[,col_nam], "C" )
    seq_data = cbind( seq_data, counts)
    colnames(seq_data)[ length(colnames(seq_data)) ] = paste(col_nam, "# cys")
  }
  
  
  
  
  # add counts for all in the parameter table
  for( i in 2:nrow(input_for_summa) ){
    # initiate new column
    append_col = rep("", nrow(seq_data))
    # find logic for which to include in it.
    append_logic = create_summary_line_logic(name = input_for_summa$name[i], 
                                             data_v = data_v[[i]], 
                                             col_v = dat[, cluster_column], 
                                             logic_list = Selected_for[,k], 
                                             logic = input_for_summa$logic[i], 
                                             comparison = input_for_summa$comparison[i],
                                             logic_output = T)
    
    # add x to the relevant columns to indicate which have the trait.
    append_col[append_logic] = "1"
    # bind column to final output
    seq_data = cbind( seq_data, append_col)
    # add a column name
    colnames(seq_data)[ length(colnames(seq_data)) ] = as.character( input_for_summa$name[i] )
  }
  # remove all the empty lines
  seq_data = seq_data[Selected_for[,k],]
  
  # write output
  write.table(seq_data,  
              file = gsub( "/", "", paste0( Final_names[k], "_parameter_count_seq-names.csv") ), 
                           col.names = T, row.names = F, sep = ",") 
  
}


#### Make ordered cluster_count and file. ####
i = 2
k = 1
unique_sequences = create_summary_line_logic(name = input_for_summa$name[i], 
                                             data_v = data_v[[i]], 
                                             col_v = dat[, cluster_column], 
                                             logic_list = Selected_for[,k], 
                                             logic = input_for_summa$logic[i], 
                                             comparison = input_for_summa$comparison[i],
                                             logic_output = T)

# count number in each cluster and save in a template for futher dfs with couster counts.
cluster_count_binders = rle( as.vector(  sort( unname( unlist( dat[cluster_column] )[unique_sequences] ) ) ) )
cluster_count_temp = cbind( cluster_count_binders$values, cluster_count_binders$lengths )
if( ncol(Selected_for) > 1 ){
  for( i in 2:ncol(Selected_for)){
    cluster_count_temp = cbind( cluster_count_temp, rep(0,nrow(cluster_count_temp)) )
    cluster_select_temp = rle( as.vector(  sort( unname( unlist( dat[cluster_column] ) )[Selected_for[,i] & unique_sequences] ) ) )
    # insert the new cluster counts in the appropriate position in the cluster_count_temp
    for ( j in 1:length(cluster_select_temp$values)){
      position = cluster_count_temp[,1] %in% cluster_select_temp$values[j]
      cluster_count_temp[position,i+1] = cluster_select_temp$lengths[j]
    }
  }
}


# order according to size of clusters
for ( i in 2:ncol(cluster_count_temp)){
  cluster_count_temp = cluster_count_temp[order( rapply( as.list(cluster_count_temp[,i]), as.integer) ),]
}

# print ordered file with cluster sizes.
colnames(cluster_count_temp) = c("Cluster", Final_names)
write.csv( cluster_count_temp[nrow(cluster_count_temp):1,], row.names = F, file = "Cluster_size_selected.csv")

#### Cluster size line plot ####
# format cluster_count for print and plot.
Cluster = rep( cluster_count_temp[,1], ncol(cluster_count_temp)-1 )
Cluster_Size = as.vector( cluster_count_temp[,2:ncol(cluster_count_temp)] )
Cluster_Size = rapply(as.list( Cluster_Size ), as.integer )
Selected = rep( Final_names, rep(nrow(cluster_count_temp), ncol(cluster_count_temp)-1) ) 

cluster_count = data.frame( Cluster, Cluster_Size , Selected)

# define GG-plot
line_plot = ggplot(data=cluster_count, aes(x = factor(Cluster, levels =  cluster_count_temp[,1] ), 
                                           y = Cluster_Size, group = factor( Selected, levels = Final_names)) ) +
  theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +
  scale_color_manual(values= sym_col[1:length(Final_names)],  breaks=Final_names) +
  labs( x = paste(nrow(cluster_count_temp), "different clusters sorted for size."), 
        title = "Cluster size plot, only unique sequences") + 
  geom_step(aes( color = Selected )) + theme(text = element_text(size=15)) +
  geom_step(data=cluster_count[cluster_count$Selected==Final_names[length(Final_names)],], 
            aes( x = factor(Cluster, levels =  cluster_count_temp[,1] ), 
                 y = Cluster_Size, group = factor( Selected, levels = Final_names) ), size = 1.3, 
            color = sym_col[length(Final_names)]) 
line_plot

# print plot
line_plot
png("Cluster_size_plot.png", width = 480*2, height = 480*2)
line_plot + theme(text = element_text(size=30))
dev.off()


# print plot in zoom
line_plot_zoom = line_plot + coord_cartesian(ylim = c(0, 20))
png("Cluster_size_plot_zoom.png", width = 480*2, height = 480*2)
line_plot_zoom + theme(text = element_text(size=30))
dev.off()
line_plot_zoom





